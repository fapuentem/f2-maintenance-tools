#+TITLE: F2 Smart Controller Health Report
#+SUBTITLE: F2-<MAC_ADDRESS>
#+AUTHOR: Fabricio Puente M.
#+EMAIL: fpuentem@visiontechconsulting.ca
#+DATE: <2025-04-07 Mon>
#+EXCLUDE_TAGS: noexport
#+OPTIONS: email:t tags:nil toc:nil
#+EXPORT_FILE_NAME: check-status
#+PROPERTY: header-args:sh :results output replace :exports both

* README                                                                        :noexport:

This document is written in a *literate programming* style and is designed to
generate a health report for an F2 Smart Controller (Jetson Orin NX).

When executed, the document automatically:

- Detects the board version.
- Retrieves the device’s MAC address and serial numbers.
- Updates the document header fields (`#+SUBTITLE:`, `#+DATE:`,
  `#+EXPORT_FILE_NAME:`) with device-specific values.

The final exported report (e.g. HTML) provides a comprehensive health overview
of the controller, including:

- System resource usage (CPU, memory, disk, network).
- Jetson-specific monitoring (GPU, thermals).
- Application-level status and logs (F2-App, BLE service, Crowd Scanning).
- General system health and configuration.

Because the document queries the actual device, each export will reflect the
current state of the F2 on which it is run. This makes it useful both for
routine monitoring and for generating formal diagnostic reports.

#+NAME: update_mac_address
#+BEGIN_SRC elisp :results none :eval never-export :var board-ver="v3.1"
  (defun net-mac-no-colon (iface)
    "Return IFACE's MAC address as 12 lowercase hex chars (no colons).
  On Linux, reads /sys/class/net/IFACE/address. Falls back to `ip` or `ifconfig`."
    (interactive
     (list (completing-read "Interface: " (mapcar #'symbol-name (network-interface-list)))))
    (let* ((sys-path (format "/sys/class/net/%s/address" iface))
           (raw
            (cond
             ;; Linux: /sys
             ((file-readable-p sys-path)
              (string-trim (with-temp-buffer
                             (insert-file-contents sys-path)
                             (buffer-string))))
             ;; ip(8)
             ((executable-find "ip")
              (with-temp-buffer
                (call-process "ip" nil t nil "link" "show" "dev" iface)
                (goto-char (point-min))
                (when (re-search-forward
                       ;; matches: "link/ether aa:bb:cc:dd:ee:ff"
                       "\\blink/ether\\s-+\\([0-9A-Fa-f:]+\\)" nil t)
                  (match-string 1))))
             ;; ifconfig
             ((executable-find "ifconfig")
              (with-temp-buffer
                (call-process "ifconfig" nil t nil iface)
                (goto-char (point-min))
                (when (re-search-forward
                       ;; matches: "ether aa:bb:cc:dd:ee:ff"
                       "\\beth(?:her)?\\s-+\\([0-9A-Fa-f:]+\\)" nil t)
                  (match-string 1))))))
           (hex (and raw (replace-regexp-in-string ":" "" (downcase raw)))))
      (unless (and hex (= (length hex) 12) (string-match-p "\\`[0-9a-f]\\{12\\}\\'" hex))
        (user-error "Could not obtain a valid MAC for %s" iface))
      (when (called-interactively-p 'interactive)
        (message "%s" hex))
      hex))

  (defun f2-board->iface (board-ver)
    "Map BOARD-VER (string) to the network interface name."
    (or (alist-get board-ver
                 '(("v3.1" . "eth1")
                   ("v3.0" . "eth2")
                   ("v2.1" . "eth2")
                   ("v2.0" . "eth0"))
                 nil nil #'string=)
      (user-error "Unknown board version: %s" board-ver)))

   (let* ((iface (f2-board->iface board-ver))
          (mac (net-mac-no-colon iface)))
        (save-excursion
          (goto-char (point-min))
          (when (re-search-forward "^#\\+SUBTITLE:.*" nil t)
            (replace-match (concat "#+SUBTITLE: " (format "f2-%s" mac))))
          (when (re-search-forward "^#\\+DATE:.*" nil t)
            (replace-match (concat "#+DATE: " (ignore (org-insert-time-stamp (current-time) t)))))
          (when (re-search-forward "^#\\+EXPORT_FILE_NAME:.*" nil t)
            (replace-match (format "#+EXPORT_FILE_NAME: f2-%s-report" mac)))))
#+END_SRC

#+NAME: sn_som
#+BEGIN_SRC elisp :results none
  (defun vt-sysfs-serial-number (&optional path)
    "Read serial number string from PATH (default Jetson path).
  Strips trailing NULs and whitespace."
    (let* ((p (or path "/sys/firmware/devicetree/base/serial-number"))
           (s (when (file-readable-p p)
                (with-temp-buffer
                  (insert-file-contents p)
                  (buffer-string)))))
      (unless s
        (error "Cannot read serial from %s" p))
      (string-trim (replace-regexp-in-string "\0+$" "" s))))
#+END_SRC

#+NAME: sn_f2
#+BEGIN_SRC elisp :results none
  (cl-defun vt-i2c-read-serial (&key (bus 1) (addr #x58) (reg #x80) (len 16) sudo)
    "Return hex string (no spaces, no 0x) read via i2ctransfer.
  BUS is the I²C bus number, ADDR the 7-bit address, REG the starting
  register, and LEN the number of bytes to read. If SUDO is non-nil,
  run the command under TRAMP /sudo::.

  Requires `i2ctransfer` from i2c-tools."
    (let* ((args (list "-f" "-y" (number-to-string bus)
                       (format "w1@0x%02x" addr)
                       (format "0x%02x" reg)
                       (format "r%d" len)))
           (default-directory (if sudo "/sudo::" default-directory)))
      (unless (executable-find "i2ctransfer")
        (error "i2ctransfer not found; install i2c-tools"))
      (with-temp-buffer
        (let ((status (apply #'process-file "i2ctransfer" nil t nil args)))
          (unless (and (integerp status) (= status 0))
            (error "i2ctransfer exit %s; output: %s" status (buffer-string)))
          ;; Example output: "0x01 0xAB 0xCD ..."
          (let* ((out   (buffer-string))
                 (clean (replace-regexp-in-string "\\(?:0x\\)\\|[^0-9A-Fa-f]" "" out)))
            (unless (string-match-p "\\`[0-9A-Fa-f]+\\'" clean)
              (error "Unexpected i2ctransfer output: %s" out))
            (downcase clean))))))
#+END_SRC

#+BEGIN_SRC elisp :results none :dir /sudo::
  (let ((som-sn (vt-sysfs-serial-number))
        (f2-sn (vt-i2c-read-serial)))
    (save-excursion
      (goto-char (point-min))
      (when (re-search-forward "^* S/N F2 carrier board:.*" nil t)
        (replace-match (concat "* S/N F2 carrier board: " (format "%s" f2-sn))))
      (when (re-search-forward "^* S/N Jetson SoM:.*" nil t)
        (replace-match (concat "* S/N Jetson SoM: " (format "%s" som-sn))))))
#+END_SRC

* Code :noexport:

#+NAME: startup
#+begin_src elisp :results none
  (load-theme 'modus-vivendi)
  (setf fill-column 100)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)))
#+end_src

* S/N F2 carrier board:

* S/N Jetson SoM:

* System Resource Monitoring

- CPU Usage:

  #+BEGIN_SRC sh
    top -bn1 | grep '^%Cpu' | awk '{print $2}'
  #+END_SRC

   #+RESULTS:

- Memory Usage:

  #+BEGIN_SRC sh
    free -h
  #+END_SRC

   #+RESULTS:

- Disk Usage:
  #+BEGIN_SRC sh
    df -h
  #+END_SRC

   #+RESULTS:
   #+begin_example

   #+end_example

- Disk I/O:
   #+BEGIN_SRC sh
     iostat -d -k 1 1
   #+END_SRC

   #+RESULTS:

- Network Interface Status:
   #+BEGIN_SRC sh
     ip a
   #+END_SRC

   #+RESULTS:
   #+begin_example

   #+end_example

   #+BEGIN_SRC sh
     netstat -s | grep -i 'error\\|drop'
   #+END_SRC

   #+RESULTS:

* Jetson Specific Monitoring
- GPU Usage:

  #+BEGIN_SRC sh
    tegrastats | head -1
  #+END_SRC

  #+RESULTS:

- Thermal Monitoring:

  #+BEGIN_SRC sh
    tegrastats | head  -1 | awk '{print $1,$2,$17,$18,$19.$20,$21,$22,$23,$24,$25}'
  #+END_SRC

  #+RESULTS:

** Application Specific Monitoring
*** F2 App

- Application Process Status:

  #+BEGIN_SRC sh
    pids=$(pgrep -f "F2-App" | grep -v "sh -c")
    if [ -z "$pids" ]; then
          echo "F2-App process is not running."
    else
          echo "F2-App is running with PID(s): $pids"
    fi
  #+END_SRC

   #+RESULTS:

- Application Logs:

   #+BEGIN_SRC sh
     tail -n 10 /home/nvidia/projects/F2-App/logs/app.log
   #+END_SRC

   #+RESULTS:
   #+begin_example

   #+end_example

- Application Resource Usage:

    #+BEGIN_SRC sh
     ps -aux | grep F2-App
   #+END_SRC

   #+RESULTS:

*** F2 App fanstel ble

- Application Process Status:

  #+BEGIN_SRC sh
    pids=$(pgrep -f "F2_App_fanstel_ble" | grep -v "sh -c")
    if [ -z "$pids" ]; then
          echo "F2_App_fanstel_ble process is not running."
    else
          echo "F2_App_fanstel_ble is running with PID(s): $pids"
    fi
  #+END_SRC

   #+RESULTS:

- Application Logs:

   #+BEGIN_SRC sh
     tail -n 20 /home/nvidia/projects/F2_App_fanstel_ble/logs/ble-app.log
   #+END_SRC

   #+RESULTS:

- Application Resource Usage:

   #+BEGIN_SRC sh
     ps -aux | grep F2_App_fanstel_ble
   #+END_SRC

   #+RESULTS:

*** F2 Crowd Scanning

 - Application Process Status:

   #+BEGIN_SRC sh
     pids=$(pgrep -f "F2_Crowd_Scanning" | grep -v "sh -c")
     if [ -z "$pids" ]; then
           echo "F2_Crowd_Scanning process is not running."
     else
         echo "F2_Crowd_Scanning is running with PID(s): $pids"
     fi
   #+END_SRC

   #+RESULTS:

 - Application Logs:

   #+BEGIN_SRC sh
     tail -n 20 /home/nvidia/projects/F2_Crowd_Scanning/logs/app.log
   #+END_SRC

   #+RESULTS:

 - Application Resource Usage:

   #+BEGIN_SRC sh
     ps -aux | grep F2_Crowd_Scanning
   #+END_SRC

   #+RESULTS:

** System Health and Configuration

- System Uptime:

   #+BEGIN_SRC sh
     uptime
   #+END_SRC

   #+RESULTS:

 - System Logs (Errors):

   #+BEGIN_SRC sh
     journalctl -p err | tail -25
   #+END_SRC

   #+RESULTS:
   #+begin_example

   #+end_example

# Local Variables:
# org-confirm-babel-evaluate: (lambda (lang body) (not (string= lang "elisp")))
# org-confirm-babel-evaluate: (lambda (lang body) (not (string= lang "sh")))
# eval: (progn
#         (when (fboundp 'org-babel-goto-named-src-block)
#           (org-babel-goto-named-src-block "startup")
#           (org-babel-execute-src-block)))
# End:
